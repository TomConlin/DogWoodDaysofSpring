#! /usr/bin/awk -f
# reduce_daymet_pixlestack_to_seasonal.awk
#
# takes a file generated by the DayMet single pixel server 
# with daily values from a range between years 
# and reduces each year of daily values
# to a row with annual & seasonal values per year at the pixle location.

# Daymet provudes a "daymet-single-pixel-batch" GH repo
# I extended their offering with bash/daymet_spt_range.sh
# which generated the files that are inout for this

BEGIN {
	FS=",";
	OFS="\t";
	# the files from daymet cnould include more or fewer columns

	# EDIT these to match the fields you have
	YEAR=1;
	YDAY=2;
	PRCP=3;
	TMAX=4;
	TMIN=5;
	#########

	BASE=0;   # deg C above which to count for growing degree day  
	# Q=91.25;  # days in a season (... unless the date range is lacking it) 
}

# these first fields are optional/extra, included 'just in case'.

/^Latitude: /{split($0,a," ");lat=a[2]; lon=a[4]}
/^X & Y on Lambert Conformal Conic: /{split($0,a," ");lccx=a[8]; lccy=a[9]}
/^Tile: /{split($0,a," ");tile=a[2]}


### annual
/^[0-9,.-]+$/{ 	
    # print "annual" > "/dev/stderr"
	range[($YEAR)]++;
	gdd = (($TMAX)+($TMIN))/2 - BASE;
	if(gdd < 0){gdd = 0};
	accp[$YEAR]+=$PRCP;
	agdd[$YEAR] += gdd;
}

### winter before newyear
/^[0-9,.-]+$/ && (($YDAY)>335){
    # print "winter before newyear" > "/dev/stderr"
	w_prcp[(($YEAR)+1)]+=$PRCP;
	w_tmax[(($YEAR)+1)]+=$TMAX;
	w_tmin[(($YEAR)+1)]+=$TMIN;
	w_gdd[(($YEAR)+1)] += gdd;
	w_days[(($YEAR)+1)]+=1
}
### winter after newyear
/^[0-9,.-]+$/ && ($YDAY)<=62{
	# print "winter after newyear"  > /dev/stderr
	w_prcp[$YEAR]+=$PRCP;
	w_tmax[$YEAR]+=$TMAX;
	w_tmin[$YEAR]+=$TMIN;
	w_gdd[$YEAR] += gdd;
	w_days[$YEAR]+=1;
}

### spring
/^[0-9,.-]+$/ && (($YDAY)>62) && (($YDAY)<=152){
	# print "spring"  > "/dev/stderr"
	sp_prcp[$YEAR]+=$4;
	sp_tmax[$YEAR]+=$TMAX;
	sp_tmin[$YEAR]+=$TMIN;
	sp_gdd[$YEAR] += gdd;
	sp_days[$YEAR]+=1;
}

### summer
/^[0-9,.-]+$/ && (($YDAY)>152) && (($YDAY)<=243){
	# print "summer"  > "/dev/stderr"
	su_prcp[$YEAR]+=$PRCP;
	su_tmax[$YEAR]+=$TMAX;
	su_tmin[$YEAR]+=$TMIN;
	su_gdd[$YEAR] += gdd;
	su_days[$YEAR]+=1;
}

### autum
/^[0-9,.-]+$/ && (($YDAY)>243) && (($YDAY)<=335){
	# print "autum"  > "/dev/stderr"
	au_prcp[$YEAR]+=$PRCP;
	au_tmax[$YEAR]+=$TMAX;
	au_tmin[$YEAR]+=$TMIN;
	au_gdd[$YEAR] += gdd;
	au_days[$YEAR]+=1;
}

####################################

END{

	# lat, lon,  year,
	# AGDD,AGDD_in_F, 
	# Tmax_Winter,Tmax_Spring,Tmax_Summer,Tmax_Fall,
	# Tmin_Winter,Tmin_Spring,Tmin_Summer,Tmin_Fall,
	# Prcp_Winter,Prcp_Spring,Prcp_Summer,Prcp_Fall,
	# Accum_Prcp,
	# lccx, lccy, tile
	
	n = asorti(range,ranges)	
	#print "found " n " years from " ranges[1] " to " ranges[n]	 > "/dev/stderr"

	for(y=1; y<=n; y++){
		year = ranges[y];
		winter = w_days[year];
		spring = sp_days[year];
		summer = su_days[year];
		autum = au_days[year];
			
		print  lat, lon, year,
		agdd[year],	agdd[year]*9/5+32,
		w_tmax[year]/winter,sp_tmax[year]/spring,su_tmax[year]/summer,au_tmax[year]/autum,
		w_tmin[year]/winter,sp_tmin[year]/spring,su_tmin[year]/summer,au_tmin[year]/autum,
		w_prcp[year],       sp_prcp[year] ,      su_prcp[year],       au_prcp[year],
		accp[year]
		#,lccx, lccy, tile
	}
}

